# Captcha Functions
#------------------

#' @title Transforms an image to black & white
#' @export
#' 
#' @description \code{img2Black} transforms a multilayered and multicolored 
#' captcha into a black & white image. The values are (rgb = 0) for black and 
#' (rbg = 255) for white.
#'  
#' @param img A matrix of imagedata resulting from a readJpeg import.
#' 
#' @examples
#' captcha <- readJpeg('prog_captcha/captcha1.jpg')
#' captcha <- img2Black(captcha)

img2Black <- function(img){
  require(biOps)

  # make dark colors dark and light colors light
  limit <- 150
  img[img < limit] <- 0
  img[img >= limit] <- 255
  
  # Image to grey Scale
  img <- imgRGB2Grey(img)
  
  # make dark colors dark and light colors light
  limit <- 200
  img[img < limit] <- 0
  img[img >= limit] <- 255
  
  # Remove all inbetween shades
  limit <- 0
  img[img <= limit] <- 0
  img[img > limit] <- 255
  img  
}

#' @title Find parts of an image that is white
#' @export
#' 
#' @description \code{isWhite} is looking for the parts in an image that are  
#' white (rgb = 255) and returns a logical (T or F) vecotr.
#'  
#' @param img A matrix of imagedata resulting from a readJpeg import.
#' @param axes Either 'v' or 'h', is the image scaned trough vertically or 
#' horizontally.
#' 
#' @examples
#' whiteVector <- isWhite(letter, axes = 'h')

isWhite <- function(img, axes = 'v'){
  width <- length(img[1, ])
  height <- length(img[, 1])
  
  dfWhite <- NULL
  # Cut off vertically
  if(axes == 'v'){
    for(x in 1:width){
      dfWhite[x] <- sum(img[, x] != 255)
    }    
  }
  
  # Cut off horizontally  
  if(axes == 'h'){
    for(y in 1:height){
      dfWhite[y] <- sum(img[y, ] != 255)
    }    
  }
  
  dfWhite > 0
}

# Cut-off whitespace (with 1px white)
cutWhite <- function(letter){
  require(biOps)
  
  # Length & Width
  width <- length(letter[1, ])
  height <- length(letter[, 1])
  
  # Run length encoding
  rleHoriz <- rle(isWhite(letter, axes = 'h'))
  rleVerti <- rle(isWhite(letter, axes = 'v'))
  
  # Margins (with 1px white)
  TM <- rleHoriz$lengths[1]
  RM <- rleVerti$lengths[length(rleVerti$lengths)] - 1
  BM <- rleHoriz$lengths[length(rleHoriz$lengths)] - 1
  LM <- rleVerti$lengths[1]
  rleHoriz$values[1] == F
  
  rleVerti
  data.frame(letter)
  letter[TM:(height - BM), LM:(width - RM)]
  
  # cutting according to css box model
  letter <- letter[TM:(height - BM), LM:(width - RM)]
  imagedata(letter)
}

# Seperate letters (with the help of the above function)
sepLetter <- function(img, nLetter){
  
  width <- length(img[1, ])
  height <- length(img[, 1])
  
  # Run length encoding
  rleVerti <- rle(isWhite(img, axes = 'v'))
  rleVerti$cumsum <- cumsum(rleVerti$lengths)
  
  # x Coordinates left and right side
  xLeft <- rleVerti$cumsum[rleVerti$values == F][1:(length(rleVerti$cumsum[rleVerti$values == F])-1)]
  xRight <- rleVerti$cumsum[rleVerti$values == T] + 1
  
  # Cut letter
  letter <- img[, xLeft[nLetter]:xRight[nLetter]]
  imagedata(cutWhite(letter))
}  

# Creat a Canvas
makeCanvas <- function(nrows, ncols){
  canvas <- imagedata(matrix(data = rep(255, nrows * ncols), nrow = nrows, ncol = ncols))
  canvas
}

# Rotate a letter
rotLetter <- function(letter, cSize, angle, cutoff = 1/5){
  require(biOps)
  require(EBImage)
  
  # Prepare canvas
  canvas <- makeCanvas(nrows = cSize, ncols = cSize)
  
  # Center coordinates of the canvas (e.g., c(50, 50))
  centerX <- nrow(letter)/2
  centerY <- ncol(letter)/2
  
  # Zero coordinates of the canvas c(0, 0)
  zeroX <- cSize/2 - centerX
  zeroY <- cSize/2 - centerY
  
  # Max. width and max. height of the letter
  widthX <- length(letter[, 1])
  heightY <- length(letter[1, ])
  
  # Plot the letter on the canvas
  for(y in 1:heightY){
    for(x in 1:widthX){
      canvas[zeroX + (x - 1), zeroY + (y - 1)] <- letter[x, y]
    }
  }
  
  # Rotate the canvas
  rCanvas <- rotate(canvas, angle = angle)
  
  # Cut the Canvas by a percentage
  rCanvas <- rCanvas[(cutoff * cSize):((1 - cutoff) * cSize),
                     (cutoff * cSize):((1 - cutoff) * cSize)]
  
  imagedata(rCanvas)  
}


# Sharpen an image to max
sharpenImage <- function(img){
  img[img > 255/2] <- 255
  img[img < 255/2] <- 0
  img
}

# Is a letter a M or W
isMW <- function(letter){
  require(biOps)
  
  width <- letter[1, ]
  height <- letter[, 1]
  
  nPixel <- round(length(width) * 2/5)
  nPixel2 <- round(length(width) * 1/15)
  
  xLeft <- letter[, (1 + nPixel2):nPixel]
  xRight <- letter[, (length(letter[1, ]) - nPixel):(length(letter[1, ]) - nPixel2)]
  
  xLeft <- isWhite(sharpenImage(xLeft), axes = 'h')
  xRight <- isWhite(sharpenImage(xRight), axes = 'h')
  
  rleLeft <- rle(xLeft)
  rleRight <- rle(xRight)
  
  x <- NULL  
  if(length(rleLeft$values) == 7){
    if(sum(rleLeft$values == c(F, T, F, T, F, T, F)) == 7){
      x[1] <- T
    }
  }
  
  if(length(rleRight$values) == 7){
    if(sum(rleRight$values == c(F, T, F, T, F, T, F)) == 7){
      x[2] <- T
    }
  }
  sum(x, na.rm = T) > 0
}

# Rotate Letter according to the width/height ration --> minimze or maximize
rotationFun <- function(letter){
  require(biOps)
  
  ## Rotate, cut horizontal and vertical whitespace / get the width
  rotation <- c(0, 5, 10, 15, 20, 25, 30, 35, 40, 45, 50, -5, -10, -15, -20,
                -25, -30, -35, -40, -45, -50)
  #   rotation <- c(0, 22.5, 45, 67.5, 90, -22.5, -45, -67.5, -90)
  df <- data.frame(rotation)
  
  for(i in 1:length(rotation)){
    df$width[i] <- length(cutWhite(rotLetter(letter, cSize = 100, angle = rotation[i], cutoff = 1/5))[1, ])
    df$height[i] <- length(cutWhite(rotLetter(letter, cSize = 100, angle = rotation[i], cutoff = 1/5))[, 1])
  }
  
  # min width
  df$opt <- df$width
  optRotation <- df$rotation[df$opt == min(df$opt)][1]
  
  # Rotate the letter
  letter_temp <- cutWhite(rotLetter(letter, cSize = 100, angle = optRotation, cutoff = 1/5))
  
  # Check if not a M or W
  if(isMW(letter_temp)){
    df <- data.frame(rotation)
    
    for(i in 1:length(rotation)){
      df$width[i] <- length(cutWhite(rotLetter(letter, cSize = 100, angle = rotation[i], cutoff = 1/5))[1, ])
      df$height[i] <- length(cutWhite(rotLetter(letter, cSize = 100, angle = rotation[i], cutoff = 1/5))[, 1])
    }
    
    # max width
    df$opt <- df$width
    optRotation <- df$rotation[df$opt == max(df$opt)][1]
    
    letter_temp <- cutWhite(rotLetter(letter, cSize = 100, angle = optRotation, cutoff = 1/5))
  }
  letter_temp
}

# Plot Letter on a canvas
plotLetters <- function(letter, canvas, number, widthLetter = 30){
  
  # Max. width and max. height of the letter
  widthX <- length(letter[, 1])
  heightY <- length(letter[1, ])
  
  # Zero coordinates of the canvas c(Y, X)
  zeroY <- length(canvas[, 1])/2
  zeroX <- 10 + (widthLetter * (number - 1))
  
  # Plot the letter on the canvas
  for(y in 1:heightY){
    for(x in 1:widthX){
      canvas[zeroY + (x - 1), zeroX + (y - 1)] <- letter[x, y]
    }
  } 
  
  imagedata(canvas)
}

# Rotate Letter randomly
rotateAndCombine <- function(letter){
  require(biOps)
  
  ## Rotate, cut horizontal and vertical whitespace / get the width
  rotation <- seq(-55, 55, by = 5)
  
  # Prepare canvas
  canvas <- makeCanvas(nrows = 70, ncols = 800)
  
  # Rotate the letter
  for(i in 1:length(rotation)){
    canvas <- plotLetters(cutWhite(rotLetter(letter, cSize = 100, angle = rotation[i], cutoff = 1/5)), canvas, number = i)
  }
  
  
  canvas
}

# OCR by tesseract
ocrTesseract <- function(canvas){
  # Write canvas to tiff
  writeTiff('prog_captcha/canvas.tiff', canvas)
  
  # OCR trough tesseract
  system("tesseract C:/Users/CIB/Documents/R/web-scraping/prog_captcha/canvas.tiff C:/Users/CIB/Documents/R/web-scraping/prog_captcha/canvas letters", wait = T)
  result <- paste(readLines("prog_captcha/canvas.txt"), collapse = "")
  
  # Gsub
  result <- tolower(result)
  result <- gsub(' ', '', result)
  count <- sapply(letters, function(x){x <- sum(x == unlist(strsplit(result, "")))})
  count
  names(count)[count == max(count)]  
}
